/*
 * Microsoft Public License (Ms-PL) - Copyright (c) 2020-2021 Sean Moss
 * This file is subject to the terms and conditions of the Microsoft Public License, the text of which can be found in
 * the 'LICENSE' file at the root of this repository, or online at <https://opensource.org/licenses/MS-PL>.
 */

#include "./Shaderc.hpp"

#include <shaderc/shaderc.hpp>

#include <fstream>


namespace vsl
{

// ====================================================================================================================
Shaderc::Shaderc(const CompilerOptions* options, const Generator* generator)
	: compiler_{ std::make_shared<shaderc::Compiler>() }
	, options_{ options }
	, generator_{ generator }
	, lastError_{ }
	, stages_{ }
	, bytecodes_{ }
{

}

// ====================================================================================================================
Shaderc::~Shaderc()
{

}

// ====================================================================================================================
bool Shaderc::compileStage(ShaderStages stage)
{
	const auto stageName = ShaderStageToStr(stage);

	// Get the stage string
	string source{};
	if (!generator_->getStageString(stage, &source)) {
		lastError_ = { CompilerStage::Compile, "Invalid stage for compilation - stage not found" };
		return false;
	}

	// Save the generated intermediate source
	if (options_->saveIntermediate() && !writeIntermediate(stage, source)) {
		return false;
	}

	// Create the compiler options
	shaderc::CompileOptions opts{};
	opts.SetOptimizationLevel(options_->disableOptimization()
		? shaderc_optimization_level_zero
		: shaderc_optimization_level_performance);
	opts.SetTargetSpirv(shaderc_spirv_version_1_0);

	// Perform the compilation
	const auto skind =
		(stage == ShaderStages::Vertex) ? shaderc_vertex_shader :
		(stage == ShaderStages::TessControl) ? shaderc_tess_control_shader :
		(stage == ShaderStages::TessEval) ? shaderc_tess_evaluation_shader :
		(stage == ShaderStages::Geometry) ? shaderc_geometry_shader : shaderc_fragment_shader;
	const auto result = compiler_->CompileGlslToSpv(
		source,
		skind,
		"VSLC",
		"main",
		opts
	);

	// Check and report result
	if (result.GetCompilationStatus() != shaderc_compilation_status_success) {
		lastError_ = { CompilerStage::Compile, result.GetErrorMessage() };
		return false;
	}

	// Save the generated bytecode
	auto& bytecode = (bytecodes_[stage] = {});
	bytecode.insert(bytecode.end(), result.begin(), result.end());
	if (options_->saveBytecode() && !writeBytecode(stage)) {
		return false;
	}

	// Report success
	stages_ |= stage;
	return true;
}

// ====================================================================================================================
bool Shaderc::writeProgram(const ShaderInfo& info)
{
	std::ofstream file{ options_->outputFile(), std::ofstream::binary | std::ofstream::trunc };

	return true;
}

// ====================================================================================================================
bool Shaderc::writeIntermediate(ShaderStages stage, const string& source)
{
	// Write file
	const auto stageName = ShaderStageToStr(stage);
	std::ofstream file{
		mkstr("%s.%s.glsl", options_->outputFile().c_str(), stageName.c_str()),
		std::ofstream::trunc
	};
	if (!file.is_open()) {
		lastError_ = { CompilerStage::Compile, "Failed to open intermediate file for output" };
		return false;
	}
	file << source << std::endl;

	return true;
}

// ====================================================================================================================
bool Shaderc::writeBytecode(ShaderStages stage)
{
	// Check for stage
	const auto bcit = bytecodes_.find(stage);
	if (bcit == bytecodes_.end()) {
		lastError_ = { CompilerStage::Compile, "Cannot write bytecode for non-compiled stage" };
		return false;
	}

	// Write file
	const auto stageName = ShaderStageToStr(stage);
	std::ofstream file { 
		mkstr("%s.%s.spv", options_->outputFile().c_str(), stageName.c_str()), 
		std::ofstream::binary | std::ofstream::trunc
	};
	if (!file.is_open()) {
		lastError_ = { CompilerStage::Compile, "Failed to open bytecode file for output" };
		return false;
	}
	file.write(reinterpret_cast<const char*>(bcit->second.data()), bcit->second.size() * sizeof(uint32));

	return true;
}

} // namespace vsl
