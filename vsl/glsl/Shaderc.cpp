/*
 * Microsoft Public License (Ms-PL) - Copyright (c) 2020-2021 Sean Moss
 * This file is subject to the terms and conditions of the Microsoft Public License, the text of which can be found in
 * the 'LICENSE' file at the root of this repository, or online at <https://opensource.org/licenses/MS-PL>.
 */

#include "./Shaderc.hpp"

#include <shaderc/shaderc.hpp>

#include <fstream>


namespace vsl
{

#pragma pack(push, 1)
// Used as a known layout object to write binding info to a shader file
struct binding_record final
{
	uint8 slot;
	ShaderBaseType baseType;
	ShaderStages stages;
	union {
		struct {
			ImageDims dims;
			ShaderBaseType texelType;
			uint8 texelSize;
			uint8 texelComponents;
		} image;
		struct {
			uint16 size;
		} buffer;
	};
}; // struct binding_record
static_assert(sizeof(binding_record) == 8);

// Used as a known layout object to write interface variable info to shader file
struct interface_record final
{
	uint8 location;
	ShaderBaseType baseType;
	uint8 dims[2];
	uint8 arraySize;
	uint8 _pad0_[3];
}; // struct interface_record
static_assert(sizeof(interface_record) == 8);

// Used as a known layout object to write subpass input info to a shader file
struct subpass_input_record final
{
	ShaderBaseType componentType;
	uint8 componentCount;
	uint8 _pad0_[2];
}; // struct subpass_input_record
static_assert(sizeof(subpass_input_record) == 4);
#pragma pack(pop, 1)

// ====================================================================================================================
// ====================================================================================================================
Shaderc::Shaderc(const CompilerOptions* options, const Generator* generator)
	: compiler_{ std::make_shared<shaderc::Compiler>() }
	, options_{ options }
	, generator_{ generator }
	, lastError_{ }
	, stages_{ }
	, bytecodes_{ }
{

}

// ====================================================================================================================
Shaderc::~Shaderc()
{

}

// ====================================================================================================================
bool Shaderc::compileStage(ShaderStages stage)
{
	const auto stageName = ShaderStageToStr(stage);

	// Get the stage string
	string source{};
	if (!generator_->getStageString(stage, &source)) {
		lastError_ = { CompilerStage::Compile, "Invalid stage for compilation - stage not found" };
		return false;
	}

	// Save the generated intermediate source
	if (options_->saveIntermediate() && !writeIntermediate(stage, source)) {
		return false;
	}

	if (!options_->noCompile()) {
		// Create the compiler options
		shaderc::CompileOptions opts{};
		opts.SetOptimizationLevel(options_->disableOptimization()
			? shaderc_optimization_level_zero
			: shaderc_optimization_level_performance);
		opts.SetTargetSpirv(shaderc_spirv_version_1_0);

		// Perform the compilation
		const auto skind =
			(stage == ShaderStages::Vertex) ? shaderc_vertex_shader :
			(stage == ShaderStages::TessControl) ? shaderc_tess_control_shader :
			(stage == ShaderStages::TessEval) ? shaderc_tess_evaluation_shader :
			(stage == ShaderStages::Geometry) ? shaderc_geometry_shader : shaderc_fragment_shader;
		const auto result = compiler_->CompileGlslToSpv(
			source,
			skind,
			"VSLC",
			"main",
			opts
		);

		// Check and report result
		if (result.GetCompilationStatus() != shaderc_compilation_status_success) {
			lastError_ = { CompilerStage::Compile, result.GetErrorMessage() };
			return false;
		}

		// Save the generated bytecode
		auto& bytecode = (bytecodes_[stage] = {});
		bytecode.insert(bytecode.end(), result.begin(), result.end());
		if (options_->saveBytecode() && !writeBytecode(stage)) {
			return false;
		}
	}

	// Report success
	stages_ |= stage;
	return true;
}

// ====================================================================================================================
bool Shaderc::writeProgram(const ShaderInfo& info)
{
	if (options_->noCompile()) {
		return true;
	}

	// Open file and write magic number ("VBC" + uint8(1) version)
	std::ofstream file{ options_->outputFile(), std::ofstream::binary | std::ofstream::trunc };
	file << "VBC" << uint8(1);

	// Write the shader type (1 = graphics)
	file << uint8(1);

	// Write bytecode lengths
	const uint16 sizes[5]{
		uint16(bool(stages_ & ShaderStages::Vertex) ? bytecodes_[ShaderStages::Vertex].size() : 0),
		uint16(bool(stages_ & ShaderStages::TessControl) ? bytecodes_[ShaderStages::TessControl].size() : 0),
		uint16(bool(stages_ & ShaderStages::TessEval) ? bytecodes_[ShaderStages::TessEval].size() : 0),
		uint16(bool(stages_ & ShaderStages::Geometry) ? bytecodes_[ShaderStages::Geometry].size() : 0),
		uint16(bool(stages_ & ShaderStages::Fragment) ? bytecodes_[ShaderStages::Fragment].size() : 0)
	};
	file.write(reinterpret_cast<const char*>(sizes), sizeof(sizes));

	// Write table sizes
	file.write(reinterpret_cast<const char*>(&(options_->tableSizes())), sizeof(BindingTableSizes));

	// Write the vertex inputs
	std::vector<interface_record> inputs{};
	for (const auto& invar : info.inputs()) {
		interface_record irec{};
		irec.location = uint8(invar.location);
		irec.baseType = invar.type->baseType;
		irec.dims[0] = invar.type->numeric.dims[0];
		irec.dims[1] = invar.type->numeric.dims[1];
		irec.arraySize = invar.arraySize;
		inputs.push_back(irec);
	}
	const auto inputCount = uint32(inputs.size());
	file.write(reinterpret_cast<const char*>(&inputCount), sizeof(inputCount));
	file.write(reinterpret_cast<const char*>(inputs.data()), inputs.size() * sizeof(interface_record));

	// Write the fragment outputs
	std::vector<interface_record> outputs{};
	for (const auto& outvar : info.outputs()) {
		interface_record irec{};
		irec.location = uint8(outvar.location);
		irec.baseType = outvar.type->baseType;
		irec.dims[0] = outvar.type->numeric.dims[0];
		irec.dims[1] = 1;
		irec.arraySize = 1;
		outputs.push_back(irec);
	}
	const auto outputCount = uint32(outputs.size());
	file.write(reinterpret_cast<const char*>(&outputCount), sizeof(outputCount));
	file.write(reinterpret_cast<const char*>(outputs.data()), outputs.size() * sizeof(interface_record));

	// Write the bindings
	std::vector<binding_record> bindings{};
	for (const auto& binding : info.bindings()) {
		binding_record brec{};
		brec.slot = binding.slot;
		brec.baseType = binding.type->baseType;
		brec.stages = binding.stages;
		if (binding.type->isBuffer()) {
			brec.buffer.size = binding.type->buffer.structType->getStructSize();
		}
		else if (binding.type->baseType == ShaderBaseType::Sampler) {
			brec.image.dims = binding.type->image.dims;
		}
		else if (binding.type->baseType == ShaderBaseType::Image) {
			brec.image.dims = binding.type->image.dims;
			brec.image.texelType = binding.type->image.texel.type;
			brec.image.texelSize = binding.type->image.texel.size;
			brec.image.texelComponents = binding.type->image.texel.components;
		}
		else if (binding.type->baseType == ShaderBaseType::RWTexels) {
			brec.image.dims = ImageDims::Buffer;
			brec.image.texelType = binding.type->image.texel.type;
			brec.image.texelSize = binding.type->image.texel.size;
			brec.image.texelComponents = binding.type->image.texel.components;
		}
		bindings.push_back(brec);
	}
	const auto bindingCount = uint32(bindings.size());
	file.write(reinterpret_cast<const char*>(&bindingCount), sizeof(bindingCount));
	file.write(reinterpret_cast<const char*>(bindings.data()), bindings.size() * sizeof(binding_record));

	// Write the uniform data
	const auto uniformSize = info.uniform().type->getStructSize();
	file.write(reinterpret_cast<const char*>(&uniformSize), sizeof(uniformSize));
	file.write(reinterpret_cast<const char*>(&info.uniform().stages), sizeof(info.uniform().stages));
	const auto uniformMemCount = uint32(info.uniform().type->userStruct.members.size());
	file.write(reinterpret_cast<const char*>(&uniformMemCount), sizeof(uniformMemCount));
	if (uniformMemCount > 0) {
		std::vector<uint32> offsets{};
		info.uniform().type->getMemberOffsets(offsets);
		for (uint32 i = 0; i < offsets.size(); ++i) {
			file.write(reinterpret_cast<const char*>(&offsets[i]), sizeof(offsets[i]));
			const auto& name = info.uniform().type->userStruct.members[i].name;
			const auto nameLen = uint32(name.length());
			file.write(reinterpret_cast<const char*>(&nameLen), sizeof(nameLen));
			file.write(name.c_str(), nameLen);
		}
	}

	// Write the subpass inputs
	const auto spiCount = uint32(info.subpassInputs().size());
	file.write(reinterpret_cast<const char*>(&spiCount), sizeof(spiCount));
	if (spiCount > 0) {
		std::vector<subpass_input_record> spis{};
		for (const auto& spi : info.subpassInputs()) {
			subpass_input_record spirec{};
			spirec.componentType = spi.type;
			spirec.componentCount = spi.componentCount;
			spis.push_back(spirec);
		}
		file.write(reinterpret_cast<const char*>(spis.data()), spis.size() * sizeof(subpass_input_record));
	}

	// Write the bytecodes
	if (bool(stages_ & ShaderStages::Vertex)) {
		const auto& bcode = bytecodes_[ShaderStages::Vertex];
		file.write(reinterpret_cast<const char*>(bcode.data()), bcode.size() * sizeof(uint32));
	}
	if (bool(stages_ & ShaderStages::TessControl)) {
		const auto& bcode = bytecodes_[ShaderStages::TessControl];
		file.write(reinterpret_cast<const char*>(bcode.data()), bcode.size() * sizeof(uint32));
	}
	if (bool(stages_ & ShaderStages::TessEval)) {
		const auto& bcode = bytecodes_[ShaderStages::TessEval];
		file.write(reinterpret_cast<const char*>(bcode.data()), bcode.size() * sizeof(uint32));
	}
	if (bool(stages_ & ShaderStages::Geometry)) {
		const auto& bcode = bytecodes_[ShaderStages::Geometry];
		file.write(reinterpret_cast<const char*>(bcode.data()), bcode.size() * sizeof(uint32));
	}
	if (bool(stages_ & ShaderStages::Fragment)) {
		const auto& bcode = bytecodes_[ShaderStages::Fragment];
		file.write(reinterpret_cast<const char*>(bcode.data()), bcode.size() * sizeof(uint32));
	}

	return true;
}

// ====================================================================================================================
bool Shaderc::writeIntermediate(ShaderStages stage, const string& source)
{
	// Write file
	const auto stageName = ShaderStageToStr(stage);
	std::ofstream file{
		mkstr("%s.%s.glsl", options_->outputFile().c_str(), stageName.c_str()),
		std::ofstream::trunc
	};
	if (!file.is_open()) {
		lastError_ = { CompilerStage::Compile, "Failed to open intermediate file for output" };
		return false;
	}
	file << source << std::endl;

	return true;
}

// ====================================================================================================================
bool Shaderc::writeBytecode(ShaderStages stage)
{
	// Check for stage
	const auto bcit = bytecodes_.find(stage);
	if (bcit == bytecodes_.end()) {
		lastError_ = { CompilerStage::Compile, "Cannot write bytecode for non-compiled stage" };
		return false;
	}

	// Write file
	const auto stageName = ShaderStageToStr(stage);
	std::ofstream file { 
		mkstr("%s.%s.spv", options_->outputFile().c_str(), stageName.c_str()), 
		std::ofstream::binary | std::ofstream::trunc
	};
	if (!file.is_open()) {
		lastError_ = { CompilerStage::Compile, "Failed to open bytecode file for output" };
		return false;
	}
	file.write(reinterpret_cast<const char*>(bcit->second.data()), bcit->second.size() * sizeof(uint32));

	return true;
}

} // namespace vsl
